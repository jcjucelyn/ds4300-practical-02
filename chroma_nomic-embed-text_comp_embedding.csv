Vector DB,Embedding Type,Chunk Size,Overlap,Speed (s),Memory (MB),Total Chunks,Resulting Documents
chroma,nomic-embed-text,200,0,17.3398380279541,9.188964,315,"Something with Fast Insert and Fast Search? - Binary Search Tree - a binary tree where every node in the left subtree is less than its parent and every node in the right subtree is greater than its parent. 13 Image from: https://courses.grainger.illinois.edu/cs225/sp2019/notes/bst/ - {'chunk': 'Something with Fast Insert and Fast Search? - Binary Search Tree - a binary tree where every node in the left subtree is less than its parent and every node in the right subtree is greater than its parent. 13 Image from: https://courses.grainger.illinois.edu/cs225/sp2019/notes/bst/', 'file': '02 - Foundations.pdf', 'page': '12'}
Chapter 12: Binary Search Trees A binary search tree is a binary tree with a special property called the BST-property, which is given as follows: For all nodes x and y, if y belongs to the left subtree of x, then the key at y is less than the key at x, and if y belongs to the right subtree of x, then the key at y is greater than the key at x. We will assume that the keys of a BST are pairwise distinct. Each node has the following attributes: p, left, and right, which are pointers to the parent, the left child, and the right child, respectively, and key, which is key stored at the node. 1 - {'chunk': 'Chapter 12: Binary Search Trees A binary search tree is a binary tree with a special property called the BST-property, which is given as follows: For all nodes x and y, if y belongs to the left subtree of x, then the key at y is less than the key at x, and if y belongs to the right subtree of x, then the key at y is greater than the key at x. We will assume that the keys of a BST are pairwise distinct. Each node has the following attributes: p, left, and right, which are pointers to the parent, the left child, and the right child, respectively, and key, which is key stored at the node. 1', 'file': 'C12-bst.pdf', 'page': '0'}
time we insert a key into our binary search tree, it would ideally still be a perfect binary tree, in which case we'd know that the height of the tree would always be (log n), with a commensurate effect on performance. - {'chunk': ""time we insert a key into our binary search tree, it would ideally still be a perfect binary tree, in which case we'd know that the height of the tree would always be (log n), with a commensurate effect on performance."", 'file': 'ICS 46 Spring 2022, Notes and Examples_ AVL Trees.pdf', 'page': '0'}
The B-tree is a generalization of the 2-3 tree. Put another way, a 2-3 tree is a B-tree of order three. Normally, the size of a node in the B-tree is chosen to fill a disk block. A B- tree node implementation typically allows 100 or more children. Thus, a B-tree node is equivalent to a disk block, and a pointer value stored in the tree is actually the number of the block containing the child node (usually interpreted as an offset from the beginning of the corresponding disk file). In a typical application, the B-trees access to the disk file will be managed using a buffer pool and a block-replacement scheme such as LRU. Figure 12.6.1 shows a B-tree of order four. Each node contains up to three keys, and internal nodes have up to four children. Figure 12.6.1: A B-tree of order four. Search in a B-tree is a generalization of search in a 2-3 tree. It is an alternating two- step process, beginning with the root node of the B-tree. 1. Perform a binary search on the records in the current node. If a record with the search key is found, then return that record. If the - {'chunk': 'The B-tree is a generalization of the 2-3 tree. Put another way, a 2-3 tree is a B-tree of order three. Normally, the size of a node in the B-tree is chosen to fill a disk block. A B- tree node implementation typically allows 100 or more children. Thus, a B-tree node is equivalent to a disk block, and a pointer value stored in the tree is actually the number of the block containing the child node (usually interpreted as an offset from the beginning of the corresponding disk file). In a typical application, the B-trees access to the disk file will be managed using a buffer pool and a block-replacement scheme such as LRU. Figure 12.6.1 shows a B-tree of order four. Each node contains up to three keys, and internal nodes have up to four children. Figure 12.6.1: A B-tree of order four. Search in a B-tree is a generalization of search in a 2-3 tree. It is an alternating two- step process, beginning with the root node of the B-tree. 1. Perform a binary search on the records in the current node. If a record with the search key is found, then return that record. If the', 'file': '12.6. B-Trees  CS3 Data Structures & Algorithms.pdf', 'page': '1'}
ICS 46 Spring 2022 | News | Course Reference | Schedule | Project Guide | Notes and Examples | Reinforcement Exercises | Grade Calculator | About Alex ICS 46 Spring 2022 Notes and Examples: AVL Trees Why we must care about binary search tree balancing We've seen previously that the performance characteristics of binary search trees can vary rather wildly, and that they're mainly dependent on the shape of the tree, with the height of the tree being the key determining factor. By definition, binary search trees restrict what keys are allowed to present in which nodes smaller keys have to be in left subtrees and larger keys in right subtrees but they specify no restriction on the tree's shape, meaning that both of these are perfectly legal binary search trees containing the keys 1, 2, 3, 4, 5, 6, and 7. Yet, while both of these are legal, one is better than the other, because the height of the first tree (called a perfect binary tree) is smaller than the height of the second (called a degenerate tree). These two shapes represent the two extremes the best and worst possible shapes for a binary search tree containing seven keys. - {'chunk': ""ICS 46 Spring 2022 | News | Course Reference | Schedule | Project Guide | Notes and Examples | Reinforcement Exercises | Grade Calculator | About Alex ICS 46 Spring 2022 Notes and Examples: AVL Trees Why we must care about binary search tree balancing We've seen previously that the performance characteristics of binary search trees can vary rather wildly, and that they're mainly dependent on the shape of the tree, with the height of the tree being the key determining factor. By definition, binary search trees restrict what keys are allowed to present in which nodes smaller keys have to be in left subtrees and larger keys in right subtrees but they specify no restriction on the tree's shape, meaning that both of these are perfectly legal binary search trees containing the keys 1, 2, 3, 4, 5, 6, and 7. Yet, while both of these are legal, one is better than the other, because the height of the first tree (called a perfect binary tree) is smaller than the height of the second (called a degenerate tree). These two shapes represent the two extremes the best and worst possible shapes for a binary search tree containing seven keys."", 'file': 'ICS 46 Spring 2022, Notes and Examples_ AVL Trees.pdf', 'page': '0'}"
chroma,nomic-embed-text,200,50,18.906037092208862,8.962139,325,"Something with Fast Insert and Fast Search? - Binary Search Tree - a binary tree where every node in the left subtree is less than its parent and every node in the right subtree is greater than its parent. 13 Image from: https://courses.grainger.illinois.edu/cs225/sp2019/notes/bst/ - {'chunk': 'Something with Fast Insert and Fast Search? - Binary Search Tree - a binary tree where every node in the left subtree is less than its parent and every node in the right subtree is greater than its parent. 13 Image from: https://courses.grainger.illinois.edu/cs225/sp2019/notes/bst/', 'file': '02 - Foundations.pdf', 'page': '12'}
Chapter 12: Binary Search Trees A binary search tree is a binary tree with a special property called the BST-property, which is given as follows: For all nodes x and y, if y belongs to the left subtree of x, then the key at y is less than the key at x, and if y belongs to the right subtree of x, then the key at y is greater than the key at x. We will assume that the keys of a BST are pairwise distinct. Each node has the following attributes: p, left, and right, which are pointers to the parent, the left child, and the right child, respectively, and key, which is key stored at the node. 1 - {'chunk': 'Chapter 12: Binary Search Trees A binary search tree is a binary tree with a special property called the BST-property, which is given as follows: For all nodes x and y, if y belongs to the left subtree of x, then the key at y is less than the key at x, and if y belongs to the right subtree of x, then the key at y is greater than the key at x. We will assume that the keys of a BST are pairwise distinct. Each node has the following attributes: p, left, and right, which are pointers to the parent, the left child, and the right child, respectively, and key, which is key stored at the node. 1', 'file': 'C12-bst.pdf', 'page': '0'}
time we insert a key into our binary search tree, it would ideally still be a perfect binary tree, in which case we'd know that the height of the tree would always be (log n), with a commensurate effect on performance. - {'chunk': ""time we insert a key into our binary search tree, it would ideally still be a perfect binary tree, in which case we'd know that the height of the tree would always be (log n), with a commensurate effect on performance."", 'file': 'ICS 46 Spring 2022, Notes and Examples_ AVL Trees.pdf', 'page': '0'}
The B-tree is a generalization of the 2-3 tree. Put another way, a 2-3 tree is a B-tree of order three. Normally, the size of a node in the B-tree is chosen to fill a disk block. A B- tree node implementation typically allows 100 or more children. Thus, a B-tree node is equivalent to a disk block, and a pointer value stored in the tree is actually the number of the block containing the child node (usually interpreted as an offset from the beginning of the corresponding disk file). In a typical application, the B-trees access to the disk file will be managed using a buffer pool and a block-replacement scheme such as LRU. Figure 12.6.1 shows a B-tree of order four. Each node contains up to three keys, and internal nodes have up to four children. Figure 12.6.1: A B-tree of order four. Search in a B-tree is a generalization of search in a 2-3 tree. It is an alternating two- step process, beginning with the root node of the B-tree. 1. Perform a binary search on the records in the current node. If a record with the search key is found, then return that record. If the - {'chunk': 'The B-tree is a generalization of the 2-3 tree. Put another way, a 2-3 tree is a B-tree of order three. Normally, the size of a node in the B-tree is chosen to fill a disk block. A B- tree node implementation typically allows 100 or more children. Thus, a B-tree node is equivalent to a disk block, and a pointer value stored in the tree is actually the number of the block containing the child node (usually interpreted as an offset from the beginning of the corresponding disk file). In a typical application, the B-trees access to the disk file will be managed using a buffer pool and a block-replacement scheme such as LRU. Figure 12.6.1 shows a B-tree of order four. Each node contains up to three keys, and internal nodes have up to four children. Figure 12.6.1: A B-tree of order four. Search in a B-tree is a generalization of search in a 2-3 tree. It is an alternating two- step process, beginning with the root node of the B-tree. 1. Perform a binary search on the records in the current node. If a record with the search key is found, then return that record. If the', 'file': '12.6. B-Trees  CS3 Data Structures & Algorithms.pdf', 'page': '1'}
ICS 46 Spring 2022 | News | Course Reference | Schedule | Project Guide | Notes and Examples | Reinforcement Exercises | Grade Calculator | About Alex ICS 46 Spring 2022 Notes and Examples: AVL Trees Why we must care about binary search tree balancing We've seen previously that the performance characteristics of binary search trees can vary rather wildly, and that they're mainly dependent on the shape of the tree, with the height of the tree being the key determining factor. By definition, binary search trees restrict what keys are allowed to present in which nodes smaller keys have to be in left subtrees and larger keys in right subtrees but they specify no restriction on the tree's shape, meaning that both of these are perfectly legal binary search trees containing the keys 1, 2, 3, 4, 5, 6, and 7. Yet, while both of these are legal, one is better than the other, because the height of the first tree (called a perfect binary tree) is smaller than the height of the second (called a degenerate tree). These two shapes represent the two extremes the best and worst possible shapes for a binary search tree containing seven keys. - {'chunk': ""ICS 46 Spring 2022 | News | Course Reference | Schedule | Project Guide | Notes and Examples | Reinforcement Exercises | Grade Calculator | About Alex ICS 46 Spring 2022 Notes and Examples: AVL Trees Why we must care about binary search tree balancing We've seen previously that the performance characteristics of binary search trees can vary rather wildly, and that they're mainly dependent on the shape of the tree, with the height of the tree being the key determining factor. By definition, binary search trees restrict what keys are allowed to present in which nodes smaller keys have to be in left subtrees and larger keys in right subtrees but they specify no restriction on the tree's shape, meaning that both of these are perfectly legal binary search trees containing the keys 1, 2, 3, 4, 5, 6, and 7. Yet, while both of these are legal, one is better than the other, because the height of the first tree (called a perfect binary tree) is smaller than the height of the second (called a degenerate tree). These two shapes represent the two extremes the best and worst possible shapes for a binary search tree containing seven keys."", 'file': 'ICS 46 Spring 2022, Notes and Examples_ AVL Trees.pdf', 'page': '0'}"
chroma,nomic-embed-text,200,100,20.554189205169678,9.852794,362,"Something with Fast Insert and Fast Search? - Binary Search Tree - a binary tree where every node in the left subtree is less than its parent and every node in the right subtree is greater than its parent. 13 Image from: https://courses.grainger.illinois.edu/cs225/sp2019/notes/bst/ - {'chunk': 'Something with Fast Insert and Fast Search? - Binary Search Tree - a binary tree where every node in the left subtree is less than its parent and every node in the right subtree is greater than its parent. 13 Image from: https://courses.grainger.illinois.edu/cs225/sp2019/notes/bst/', 'file': '02 - Foundations.pdf', 'page': '12'}
Chapter 12: Binary Search Trees A binary search tree is a binary tree with a special property called the BST-property, which is given as follows: For all nodes x and y, if y belongs to the left subtree of x, then the key at y is less than the key at x, and if y belongs to the right subtree of x, then the key at y is greater than the key at x. We will assume that the keys of a BST are pairwise distinct. Each node has the following attributes: p, left, and right, which are pointers to the parent, the left child, and the right child, respectively, and key, which is key stored at the node. 1 - {'chunk': 'Chapter 12: Binary Search Trees A binary search tree is a binary tree with a special property called the BST-property, which is given as follows: For all nodes x and y, if y belongs to the left subtree of x, then the key at y is less than the key at x, and if y belongs to the right subtree of x, then the key at y is greater than the key at x. We will assume that the keys of a BST are pairwise distinct. Each node has the following attributes: p, left, and right, which are pointers to the parent, the left child, and the right child, respectively, and key, which is key stored at the node. 1', 'file': 'C12-bst.pdf', 'page': '0'}
time we insert a key into our binary search tree, it would ideally still be a perfect binary tree, in which case we'd know that the height of the tree would always be (log n), with a commensurate effect on performance. - {'chunk': ""time we insert a key into our binary search tree, it would ideally still be a perfect binary tree, in which case we'd know that the height of the tree would always be (log n), with a commensurate effect on performance."", 'file': 'ICS 46 Spring 2022, Notes and Examples_ AVL Trees.pdf', 'page': '0'}
The B-tree is a generalization of the 2-3 tree. Put another way, a 2-3 tree is a B-tree of order three. Normally, the size of a node in the B-tree is chosen to fill a disk block. A B- tree node implementation typically allows 100 or more children. Thus, a B-tree node is equivalent to a disk block, and a pointer value stored in the tree is actually the number of the block containing the child node (usually interpreted as an offset from the beginning of the corresponding disk file). In a typical application, the B-trees access to the disk file will be managed using a buffer pool and a block-replacement scheme such as LRU. Figure 12.6.1 shows a B-tree of order four. Each node contains up to three keys, and internal nodes have up to four children. Figure 12.6.1: A B-tree of order four. Search in a B-tree is a generalization of search in a 2-3 tree. It is an alternating two- step process, beginning with the root node of the B-tree. 1. Perform a binary search on the records in the current node. If a record with the search key is found, then return that record. If the - {'chunk': 'The B-tree is a generalization of the 2-3 tree. Put another way, a 2-3 tree is a B-tree of order three. Normally, the size of a node in the B-tree is chosen to fill a disk block. A B- tree node implementation typically allows 100 or more children. Thus, a B-tree node is equivalent to a disk block, and a pointer value stored in the tree is actually the number of the block containing the child node (usually interpreted as an offset from the beginning of the corresponding disk file). In a typical application, the B-trees access to the disk file will be managed using a buffer pool and a block-replacement scheme such as LRU. Figure 12.6.1 shows a B-tree of order four. Each node contains up to three keys, and internal nodes have up to four children. Figure 12.6.1: A B-tree of order four. Search in a B-tree is a generalization of search in a 2-3 tree. It is an alternating two- step process, beginning with the root node of the B-tree. 1. Perform a binary search on the records in the current node. If a record with the search key is found, then return that record. If the', 'file': '12.6. B-Trees  CS3 Data Structures & Algorithms.pdf', 'page': '1'}
ICS 46 Spring 2022 | News | Course Reference | Schedule | Project Guide | Notes and Examples | Reinforcement Exercises | Grade Calculator | About Alex ICS 46 Spring 2022 Notes and Examples: AVL Trees Why we must care about binary search tree balancing We've seen previously that the performance characteristics of binary search trees can vary rather wildly, and that they're mainly dependent on the shape of the tree, with the height of the tree being the key determining factor. By definition, binary search trees restrict what keys are allowed to present in which nodes smaller keys have to be in left subtrees and larger keys in right subtrees but they specify no restriction on the tree's shape, meaning that both of these are perfectly legal binary search trees containing the keys 1, 2, 3, 4, 5, 6, and 7. Yet, while both of these are legal, one is better than the other, because the height of the first tree (called a perfect binary tree) is smaller than the height of the second (called a degenerate tree). These two shapes represent the two extremes the best and worst possible shapes for a binary search tree containing seven keys. - {'chunk': ""ICS 46 Spring 2022 | News | Course Reference | Schedule | Project Guide | Notes and Examples | Reinforcement Exercises | Grade Calculator | About Alex ICS 46 Spring 2022 Notes and Examples: AVL Trees Why we must care about binary search tree balancing We've seen previously that the performance characteristics of binary search trees can vary rather wildly, and that they're mainly dependent on the shape of the tree, with the height of the tree being the key determining factor. By definition, binary search trees restrict what keys are allowed to present in which nodes smaller keys have to be in left subtrees and larger keys in right subtrees but they specify no restriction on the tree's shape, meaning that both of these are perfectly legal binary search trees containing the keys 1, 2, 3, 4, 5, 6, and 7. Yet, while both of these are legal, one is better than the other, because the height of the first tree (called a perfect binary tree) is smaller than the height of the second (called a degenerate tree). These two shapes represent the two extremes the best and worst possible shapes for a binary search tree containing seven keys."", 'file': 'ICS 46 Spring 2022, Notes and Examples_ AVL Trees.pdf', 'page': '0'}"
chroma,nomic-embed-text,500,0,16.32008671760559,7.93159,289,"Something with Fast Insert and Fast Search? - Binary Search Tree - a binary tree where every node in the left subtree is less than its parent and every node in the right subtree is greater than its parent. 13 Image from: https://courses.grainger.illinois.edu/cs225/sp2019/notes/bst/ - {'chunk': 'Something with Fast Insert and Fast Search? - Binary Search Tree - a binary tree where every node in the left subtree is less than its parent and every node in the right subtree is greater than its parent. 13 Image from: https://courses.grainger.illinois.edu/cs225/sp2019/notes/bst/', 'file': '02 - Foundations.pdf', 'page': '12'}
Chapter 12: Binary Search Trees A binary search tree is a binary tree with a special property called the BST-property, which is given as follows: For all nodes x and y, if y belongs to the left subtree of x, then the key at y is less than the key at x, and if y belongs to the right subtree of x, then the key at y is greater than the key at x. We will assume that the keys of a BST are pairwise distinct. Each node has the following attributes: p, left, and right, which are pointers to the parent, the left child, and the right child, respectively, and key, which is key stored at the node. 1 - {'chunk': 'Chapter 12: Binary Search Trees A binary search tree is a binary tree with a special property called the BST-property, which is given as follows: For all nodes x and y, if y belongs to the left subtree of x, then the key at y is less than the key at x, and if y belongs to the right subtree of x, then the key at y is greater than the key at x. We will assume that the keys of a BST are pairwise distinct. Each node has the following attributes: p, left, and right, which are pointers to the parent, the left child, and the right child, respectively, and key, which is key stored at the node. 1', 'file': 'C12-bst.pdf', 'page': '0'}
time we insert a key into our binary search tree, it would ideally still be a perfect binary tree, in which case we'd know that the height of the tree would always be (log n), with a commensurate effect on performance. - {'chunk': ""time we insert a key into our binary search tree, it would ideally still be a perfect binary tree, in which case we'd know that the height of the tree would always be (log n), with a commensurate effect on performance."", 'file': 'ICS 46 Spring 2022, Notes and Examples_ AVL Trees.pdf', 'page': '0'}
The B-tree is a generalization of the 2-3 tree. Put another way, a 2-3 tree is a B-tree of order three. Normally, the size of a node in the B-tree is chosen to fill a disk block. A B- tree node implementation typically allows 100 or more children. Thus, a B-tree node is equivalent to a disk block, and a pointer value stored in the tree is actually the number of the block containing the child node (usually interpreted as an offset from the beginning of the corresponding disk file). In a typical application, the B-trees access to the disk file will be managed using a buffer pool and a block-replacement scheme such as LRU. Figure 12.6.1 shows a B-tree of order four. Each node contains up to three keys, and internal nodes have up to four children. Figure 12.6.1: A B-tree of order four. Search in a B-tree is a generalization of search in a 2-3 tree. It is an alternating two- step process, beginning with the root node of the B-tree. 1. Perform a binary search on the records in the current node. If a record with the search key is found, then return that record. If the - {'chunk': 'The B-tree is a generalization of the 2-3 tree. Put another way, a 2-3 tree is a B-tree of order three. Normally, the size of a node in the B-tree is chosen to fill a disk block. A B- tree node implementation typically allows 100 or more children. Thus, a B-tree node is equivalent to a disk block, and a pointer value stored in the tree is actually the number of the block containing the child node (usually interpreted as an offset from the beginning of the corresponding disk file). In a typical application, the B-trees access to the disk file will be managed using a buffer pool and a block-replacement scheme such as LRU. Figure 12.6.1 shows a B-tree of order four. Each node contains up to three keys, and internal nodes have up to four children. Figure 12.6.1: A B-tree of order four. Search in a B-tree is a generalization of search in a 2-3 tree. It is an alternating two- step process, beginning with the root node of the B-tree. 1. Perform a binary search on the records in the current node. If a record with the search key is found, then return that record. If the', 'file': '12.6. B-Trees  CS3 Data Structures & Algorithms.pdf', 'page': '1'}
ICS 46 Spring 2022 | News | Course Reference | Schedule | Project Guide | Notes and Examples | Reinforcement Exercises | Grade Calculator | About Alex ICS 46 Spring 2022 Notes and Examples: AVL Trees Why we must care about binary search tree balancing We've seen previously that the performance characteristics of binary search trees can vary rather wildly, and that they're mainly dependent on the shape of the tree, with the height of the tree being the key determining factor. By definition, binary search trees restrict what keys are allowed to present in which nodes smaller keys have to be in left subtrees and larger keys in right subtrees but they specify no restriction on the tree's shape, meaning that both of these are perfectly legal binary search trees containing the keys 1, 2, 3, 4, 5, 6, and 7. Yet, while both of these are legal, one is better than the other, because the height of the first tree (called a perfect binary tree) is smaller than the height of the second (called a degenerate tree). These two shapes represent the two extremes the best and worst possible shapes for a binary search tree containing seven keys. - {'chunk': ""ICS 46 Spring 2022 | News | Course Reference | Schedule | Project Guide | Notes and Examples | Reinforcement Exercises | Grade Calculator | About Alex ICS 46 Spring 2022 Notes and Examples: AVL Trees Why we must care about binary search tree balancing We've seen previously that the performance characteristics of binary search trees can vary rather wildly, and that they're mainly dependent on the shape of the tree, with the height of the tree being the key determining factor. By definition, binary search trees restrict what keys are allowed to present in which nodes smaller keys have to be in left subtrees and larger keys in right subtrees but they specify no restriction on the tree's shape, meaning that both of these are perfectly legal binary search trees containing the keys 1, 2, 3, 4, 5, 6, and 7. Yet, while both of these are legal, one is better than the other, because the height of the first tree (called a perfect binary tree) is smaller than the height of the second (called a degenerate tree). These two shapes represent the two extremes the best and worst possible shapes for a binary search tree containing seven keys."", 'file': 'ICS 46 Spring 2022, Notes and Examples_ AVL Trees.pdf', 'page': '0'}"
chroma,nomic-embed-text,500,50,16.134067058563232,7.830221,289,"Something with Fast Insert and Fast Search? - Binary Search Tree - a binary tree where every node in the left subtree is less than its parent and every node in the right subtree is greater than its parent. 13 Image from: https://courses.grainger.illinois.edu/cs225/sp2019/notes/bst/ - {'chunk': 'Something with Fast Insert and Fast Search? - Binary Search Tree - a binary tree where every node in the left subtree is less than its parent and every node in the right subtree is greater than its parent. 13 Image from: https://courses.grainger.illinois.edu/cs225/sp2019/notes/bst/', 'file': '02 - Foundations.pdf', 'page': '12'}
Chapter 12: Binary Search Trees A binary search tree is a binary tree with a special property called the BST-property, which is given as follows: For all nodes x and y, if y belongs to the left subtree of x, then the key at y is less than the key at x, and if y belongs to the right subtree of x, then the key at y is greater than the key at x. We will assume that the keys of a BST are pairwise distinct. Each node has the following attributes: p, left, and right, which are pointers to the parent, the left child, and the right child, respectively, and key, which is key stored at the node. 1 - {'chunk': 'Chapter 12: Binary Search Trees A binary search tree is a binary tree with a special property called the BST-property, which is given as follows: For all nodes x and y, if y belongs to the left subtree of x, then the key at y is less than the key at x, and if y belongs to the right subtree of x, then the key at y is greater than the key at x. We will assume that the keys of a BST are pairwise distinct. Each node has the following attributes: p, left, and right, which are pointers to the parent, the left child, and the right child, respectively, and key, which is key stored at the node. 1', 'file': 'C12-bst.pdf', 'page': '0'}
time we insert a key into our binary search tree, it would ideally still be a perfect binary tree, in which case we'd know that the height of the tree would always be (log n), with a commensurate effect on performance. - {'chunk': ""time we insert a key into our binary search tree, it would ideally still be a perfect binary tree, in which case we'd know that the height of the tree would always be (log n), with a commensurate effect on performance."", 'file': 'ICS 46 Spring 2022, Notes and Examples_ AVL Trees.pdf', 'page': '0'}
The B-tree is a generalization of the 2-3 tree. Put another way, a 2-3 tree is a B-tree of order three. Normally, the size of a node in the B-tree is chosen to fill a disk block. A B- tree node implementation typically allows 100 or more children. Thus, a B-tree node is equivalent to a disk block, and a pointer value stored in the tree is actually the number of the block containing the child node (usually interpreted as an offset from the beginning of the corresponding disk file). In a typical application, the B-trees access to the disk file will be managed using a buffer pool and a block-replacement scheme such as LRU. Figure 12.6.1 shows a B-tree of order four. Each node contains up to three keys, and internal nodes have up to four children. Figure 12.6.1: A B-tree of order four. Search in a B-tree is a generalization of search in a 2-3 tree. It is an alternating two- step process, beginning with the root node of the B-tree. 1. Perform a binary search on the records in the current node. If a record with the search key is found, then return that record. If the - {'chunk': 'The B-tree is a generalization of the 2-3 tree. Put another way, a 2-3 tree is a B-tree of order three. Normally, the size of a node in the B-tree is chosen to fill a disk block. A B- tree node implementation typically allows 100 or more children. Thus, a B-tree node is equivalent to a disk block, and a pointer value stored in the tree is actually the number of the block containing the child node (usually interpreted as an offset from the beginning of the corresponding disk file). In a typical application, the B-trees access to the disk file will be managed using a buffer pool and a block-replacement scheme such as LRU. Figure 12.6.1 shows a B-tree of order four. Each node contains up to three keys, and internal nodes have up to four children. Figure 12.6.1: A B-tree of order four. Search in a B-tree is a generalization of search in a 2-3 tree. It is an alternating two- step process, beginning with the root node of the B-tree. 1. Perform a binary search on the records in the current node. If a record with the search key is found, then return that record. If the', 'file': '12.6. B-Trees  CS3 Data Structures & Algorithms.pdf', 'page': '1'}
ICS 46 Spring 2022 | News | Course Reference | Schedule | Project Guide | Notes and Examples | Reinforcement Exercises | Grade Calculator | About Alex ICS 46 Spring 2022 Notes and Examples: AVL Trees Why we must care about binary search tree balancing We've seen previously that the performance characteristics of binary search trees can vary rather wildly, and that they're mainly dependent on the shape of the tree, with the height of the tree being the key determining factor. By definition, binary search trees restrict what keys are allowed to present in which nodes smaller keys have to be in left subtrees and larger keys in right subtrees but they specify no restriction on the tree's shape, meaning that both of these are perfectly legal binary search trees containing the keys 1, 2, 3, 4, 5, 6, and 7. Yet, while both of these are legal, one is better than the other, because the height of the first tree (called a perfect binary tree) is smaller than the height of the second (called a degenerate tree). These two shapes represent the two extremes the best and worst possible shapes for a binary search tree containing seven keys. - {'chunk': ""ICS 46 Spring 2022 | News | Course Reference | Schedule | Project Guide | Notes and Examples | Reinforcement Exercises | Grade Calculator | About Alex ICS 46 Spring 2022 Notes and Examples: AVL Trees Why we must care about binary search tree balancing We've seen previously that the performance characteristics of binary search trees can vary rather wildly, and that they're mainly dependent on the shape of the tree, with the height of the tree being the key determining factor. By definition, binary search trees restrict what keys are allowed to present in which nodes smaller keys have to be in left subtrees and larger keys in right subtrees but they specify no restriction on the tree's shape, meaning that both of these are perfectly legal binary search trees containing the keys 1, 2, 3, 4, 5, 6, and 7. Yet, while both of these are legal, one is better than the other, because the height of the first tree (called a perfect binary tree) is smaller than the height of the second (called a degenerate tree). These two shapes represent the two extremes the best and worst possible shapes for a binary search tree containing seven keys."", 'file': 'ICS 46 Spring 2022, Notes and Examples_ AVL Trees.pdf', 'page': '0'}"
chroma,nomic-embed-text,500,100,16.375409841537476,8.000639,294,"Something with Fast Insert and Fast Search? - Binary Search Tree - a binary tree where every node in the left subtree is less than its parent and every node in the right subtree is greater than its parent. 13 Image from: https://courses.grainger.illinois.edu/cs225/sp2019/notes/bst/ - {'chunk': 'Something with Fast Insert and Fast Search? - Binary Search Tree - a binary tree where every node in the left subtree is less than its parent and every node in the right subtree is greater than its parent. 13 Image from: https://courses.grainger.illinois.edu/cs225/sp2019/notes/bst/', 'file': '02 - Foundations.pdf', 'page': '12'}
Chapter 12: Binary Search Trees A binary search tree is a binary tree with a special property called the BST-property, which is given as follows: For all nodes x and y, if y belongs to the left subtree of x, then the key at y is less than the key at x, and if y belongs to the right subtree of x, then the key at y is greater than the key at x. We will assume that the keys of a BST are pairwise distinct. Each node has the following attributes: p, left, and right, which are pointers to the parent, the left child, and the right child, respectively, and key, which is key stored at the node. 1 - {'chunk': 'Chapter 12: Binary Search Trees A binary search tree is a binary tree with a special property called the BST-property, which is given as follows: For all nodes x and y, if y belongs to the left subtree of x, then the key at y is less than the key at x, and if y belongs to the right subtree of x, then the key at y is greater than the key at x. We will assume that the keys of a BST are pairwise distinct. Each node has the following attributes: p, left, and right, which are pointers to the parent, the left child, and the right child, respectively, and key, which is key stored at the node. 1', 'file': 'C12-bst.pdf', 'page': '0'}
time we insert a key into our binary search tree, it would ideally still be a perfect binary tree, in which case we'd know that the height of the tree would always be (log n), with a commensurate effect on performance. - {'chunk': ""time we insert a key into our binary search tree, it would ideally still be a perfect binary tree, in which case we'd know that the height of the tree would always be (log n), with a commensurate effect on performance."", 'file': 'ICS 46 Spring 2022, Notes and Examples_ AVL Trees.pdf', 'page': '0'}
The B-tree is a generalization of the 2-3 tree. Put another way, a 2-3 tree is a B-tree of order three. Normally, the size of a node in the B-tree is chosen to fill a disk block. A B- tree node implementation typically allows 100 or more children. Thus, a B-tree node is equivalent to a disk block, and a pointer value stored in the tree is actually the number of the block containing the child node (usually interpreted as an offset from the beginning of the corresponding disk file). In a typical application, the B-trees access to the disk file will be managed using a buffer pool and a block-replacement scheme such as LRU. Figure 12.6.1 shows a B-tree of order four. Each node contains up to three keys, and internal nodes have up to four children. Figure 12.6.1: A B-tree of order four. Search in a B-tree is a generalization of search in a 2-3 tree. It is an alternating two- step process, beginning with the root node of the B-tree. 1. Perform a binary search on the records in the current node. If a record with the search key is found, then return that record. If the - {'chunk': 'The B-tree is a generalization of the 2-3 tree. Put another way, a 2-3 tree is a B-tree of order three. Normally, the size of a node in the B-tree is chosen to fill a disk block. A B- tree node implementation typically allows 100 or more children. Thus, a B-tree node is equivalent to a disk block, and a pointer value stored in the tree is actually the number of the block containing the child node (usually interpreted as an offset from the beginning of the corresponding disk file). In a typical application, the B-trees access to the disk file will be managed using a buffer pool and a block-replacement scheme such as LRU. Figure 12.6.1 shows a B-tree of order four. Each node contains up to three keys, and internal nodes have up to four children. Figure 12.6.1: A B-tree of order four. Search in a B-tree is a generalization of search in a 2-3 tree. It is an alternating two- step process, beginning with the root node of the B-tree. 1. Perform a binary search on the records in the current node. If a record with the search key is found, then return that record. If the', 'file': '12.6. B-Trees  CS3 Data Structures & Algorithms.pdf', 'page': '1'}
ICS 46 Spring 2022 | News | Course Reference | Schedule | Project Guide | Notes and Examples | Reinforcement Exercises | Grade Calculator | About Alex ICS 46 Spring 2022 Notes and Examples: AVL Trees Why we must care about binary search tree balancing We've seen previously that the performance characteristics of binary search trees can vary rather wildly, and that they're mainly dependent on the shape of the tree, with the height of the tree being the key determining factor. By definition, binary search trees restrict what keys are allowed to present in which nodes smaller keys have to be in left subtrees and larger keys in right subtrees but they specify no restriction on the tree's shape, meaning that both of these are perfectly legal binary search trees containing the keys 1, 2, 3, 4, 5, 6, and 7. Yet, while both of these are legal, one is better than the other, because the height of the first tree (called a perfect binary tree) is smaller than the height of the second (called a degenerate tree). These two shapes represent the two extremes the best and worst possible shapes for a binary search tree containing seven keys. - {'chunk': ""ICS 46 Spring 2022 | News | Course Reference | Schedule | Project Guide | Notes and Examples | Reinforcement Exercises | Grade Calculator | About Alex ICS 46 Spring 2022 Notes and Examples: AVL Trees Why we must care about binary search tree balancing We've seen previously that the performance characteristics of binary search trees can vary rather wildly, and that they're mainly dependent on the shape of the tree, with the height of the tree being the key determining factor. By definition, binary search trees restrict what keys are allowed to present in which nodes smaller keys have to be in left subtrees and larger keys in right subtrees but they specify no restriction on the tree's shape, meaning that both of these are perfectly legal binary search trees containing the keys 1, 2, 3, 4, 5, 6, and 7. Yet, while both of these are legal, one is better than the other, because the height of the first tree (called a perfect binary tree) is smaller than the height of the second (called a degenerate tree). These two shapes represent the two extremes the best and worst possible shapes for a binary search tree containing seven keys."", 'file': 'ICS 46 Spring 2022, Notes and Examples_ AVL Trees.pdf', 'page': '0'}"
chroma,nomic-embed-text,1000,0,15.291855812072754,7.826279,284,"Something with Fast Insert and Fast Search? - Binary Search Tree - a binary tree where every node in the left subtree is less than its parent and every node in the right subtree is greater than its parent. 13 Image from: https://courses.grainger.illinois.edu/cs225/sp2019/notes/bst/ - {'chunk': 'Something with Fast Insert and Fast Search? - Binary Search Tree - a binary tree where every node in the left subtree is less than its parent and every node in the right subtree is greater than its parent. 13 Image from: https://courses.grainger.illinois.edu/cs225/sp2019/notes/bst/', 'file': '02 - Foundations.pdf', 'page': '12'}
Chapter 12: Binary Search Trees A binary search tree is a binary tree with a special property called the BST-property, which is given as follows: For all nodes x and y, if y belongs to the left subtree of x, then the key at y is less than the key at x, and if y belongs to the right subtree of x, then the key at y is greater than the key at x. We will assume that the keys of a BST are pairwise distinct. Each node has the following attributes: p, left, and right, which are pointers to the parent, the left child, and the right child, respectively, and key, which is key stored at the node. 1 - {'chunk': 'Chapter 12: Binary Search Trees A binary search tree is a binary tree with a special property called the BST-property, which is given as follows: For all nodes x and y, if y belongs to the left subtree of x, then the key at y is less than the key at x, and if y belongs to the right subtree of x, then the key at y is greater than the key at x. We will assume that the keys of a BST are pairwise distinct. Each node has the following attributes: p, left, and right, which are pointers to the parent, the left child, and the right child, respectively, and key, which is key stored at the node. 1', 'file': 'C12-bst.pdf', 'page': '0'}
time we insert a key into our binary search tree, it would ideally still be a perfect binary tree, in which case we'd know that the height of the tree would always be (log n), with a commensurate effect on performance. - {'chunk': ""time we insert a key into our binary search tree, it would ideally still be a perfect binary tree, in which case we'd know that the height of the tree would always be (log n), with a commensurate effect on performance."", 'file': 'ICS 46 Spring 2022, Notes and Examples_ AVL Trees.pdf', 'page': '0'}
The B-tree is a generalization of the 2-3 tree. Put another way, a 2-3 tree is a B-tree of order three. Normally, the size of a node in the B-tree is chosen to fill a disk block. A B- tree node implementation typically allows 100 or more children. Thus, a B-tree node is equivalent to a disk block, and a pointer value stored in the tree is actually the number of the block containing the child node (usually interpreted as an offset from the beginning of the corresponding disk file). In a typical application, the B-trees access to the disk file will be managed using a buffer pool and a block-replacement scheme such as LRU. Figure 12.6.1 shows a B-tree of order four. Each node contains up to three keys, and internal nodes have up to four children. Figure 12.6.1: A B-tree of order four. Search in a B-tree is a generalization of search in a 2-3 tree. It is an alternating two- step process, beginning with the root node of the B-tree. 1. Perform a binary search on the records in the current node. If a record with the search key is found, then return that record. If the - {'chunk': 'The B-tree is a generalization of the 2-3 tree. Put another way, a 2-3 tree is a B-tree of order three. Normally, the size of a node in the B-tree is chosen to fill a disk block. A B- tree node implementation typically allows 100 or more children. Thus, a B-tree node is equivalent to a disk block, and a pointer value stored in the tree is actually the number of the block containing the child node (usually interpreted as an offset from the beginning of the corresponding disk file). In a typical application, the B-trees access to the disk file will be managed using a buffer pool and a block-replacement scheme such as LRU. Figure 12.6.1 shows a B-tree of order four. Each node contains up to three keys, and internal nodes have up to four children. Figure 12.6.1: A B-tree of order four. Search in a B-tree is a generalization of search in a 2-3 tree. It is an alternating two- step process, beginning with the root node of the B-tree. 1. Perform a binary search on the records in the current node. If a record with the search key is found, then return that record. If the', 'file': '12.6. B-Trees  CS3 Data Structures & Algorithms.pdf', 'page': '1'}
ICS 46 Spring 2022 | News | Course Reference | Schedule | Project Guide | Notes and Examples | Reinforcement Exercises | Grade Calculator | About Alex ICS 46 Spring 2022 Notes and Examples: AVL Trees Why we must care about binary search tree balancing We've seen previously that the performance characteristics of binary search trees can vary rather wildly, and that they're mainly dependent on the shape of the tree, with the height of the tree being the key determining factor. By definition, binary search trees restrict what keys are allowed to present in which nodes smaller keys have to be in left subtrees and larger keys in right subtrees but they specify no restriction on the tree's shape, meaning that both of these are perfectly legal binary search trees containing the keys 1, 2, 3, 4, 5, 6, and 7. Yet, while both of these are legal, one is better than the other, because the height of the first tree (called a perfect binary tree) is smaller than the height of the second (called a degenerate tree). These two shapes represent the two extremes the best and worst possible shapes for a binary search tree containing seven keys. - {'chunk': ""ICS 46 Spring 2022 | News | Course Reference | Schedule | Project Guide | Notes and Examples | Reinforcement Exercises | Grade Calculator | About Alex ICS 46 Spring 2022 Notes and Examples: AVL Trees Why we must care about binary search tree balancing We've seen previously that the performance characteristics of binary search trees can vary rather wildly, and that they're mainly dependent on the shape of the tree, with the height of the tree being the key determining factor. By definition, binary search trees restrict what keys are allowed to present in which nodes smaller keys have to be in left subtrees and larger keys in right subtrees but they specify no restriction on the tree's shape, meaning that both of these are perfectly legal binary search trees containing the keys 1, 2, 3, 4, 5, 6, and 7. Yet, while both of these are legal, one is better than the other, because the height of the first tree (called a perfect binary tree) is smaller than the height of the second (called a degenerate tree). These two shapes represent the two extremes the best and worst possible shapes for a binary search tree containing seven keys."", 'file': 'ICS 46 Spring 2022, Notes and Examples_ AVL Trees.pdf', 'page': '0'}"
chroma,nomic-embed-text,1000,50,15.97442626953125,7.686472,284,"Something with Fast Insert and Fast Search? - Binary Search Tree - a binary tree where every node in the left subtree is less than its parent and every node in the right subtree is greater than its parent. 13 Image from: https://courses.grainger.illinois.edu/cs225/sp2019/notes/bst/ - {'chunk': 'Something with Fast Insert and Fast Search? - Binary Search Tree - a binary tree where every node in the left subtree is less than its parent and every node in the right subtree is greater than its parent. 13 Image from: https://courses.grainger.illinois.edu/cs225/sp2019/notes/bst/', 'file': '02 - Foundations.pdf', 'page': '12'}
Chapter 12: Binary Search Trees A binary search tree is a binary tree with a special property called the BST-property, which is given as follows: For all nodes x and y, if y belongs to the left subtree of x, then the key at y is less than the key at x, and if y belongs to the right subtree of x, then the key at y is greater than the key at x. We will assume that the keys of a BST are pairwise distinct. Each node has the following attributes: p, left, and right, which are pointers to the parent, the left child, and the right child, respectively, and key, which is key stored at the node. 1 - {'chunk': 'Chapter 12: Binary Search Trees A binary search tree is a binary tree with a special property called the BST-property, which is given as follows: For all nodes x and y, if y belongs to the left subtree of x, then the key at y is less than the key at x, and if y belongs to the right subtree of x, then the key at y is greater than the key at x. We will assume that the keys of a BST are pairwise distinct. Each node has the following attributes: p, left, and right, which are pointers to the parent, the left child, and the right child, respectively, and key, which is key stored at the node. 1', 'file': 'C12-bst.pdf', 'page': '0'}
time we insert a key into our binary search tree, it would ideally still be a perfect binary tree, in which case we'd know that the height of the tree would always be (log n), with a commensurate effect on performance. - {'chunk': ""time we insert a key into our binary search tree, it would ideally still be a perfect binary tree, in which case we'd know that the height of the tree would always be (log n), with a commensurate effect on performance."", 'file': 'ICS 46 Spring 2022, Notes and Examples_ AVL Trees.pdf', 'page': '0'}
The B-tree is a generalization of the 2-3 tree. Put another way, a 2-3 tree is a B-tree of order three. Normally, the size of a node in the B-tree is chosen to fill a disk block. A B- tree node implementation typically allows 100 or more children. Thus, a B-tree node is equivalent to a disk block, and a pointer value stored in the tree is actually the number of the block containing the child node (usually interpreted as an offset from the beginning of the corresponding disk file). In a typical application, the B-trees access to the disk file will be managed using a buffer pool and a block-replacement scheme such as LRU. Figure 12.6.1 shows a B-tree of order four. Each node contains up to three keys, and internal nodes have up to four children. Figure 12.6.1: A B-tree of order four. Search in a B-tree is a generalization of search in a 2-3 tree. It is an alternating two- step process, beginning with the root node of the B-tree. 1. Perform a binary search on the records in the current node. If a record with the search key is found, then return that record. If the - {'chunk': 'The B-tree is a generalization of the 2-3 tree. Put another way, a 2-3 tree is a B-tree of order three. Normally, the size of a node in the B-tree is chosen to fill a disk block. A B- tree node implementation typically allows 100 or more children. Thus, a B-tree node is equivalent to a disk block, and a pointer value stored in the tree is actually the number of the block containing the child node (usually interpreted as an offset from the beginning of the corresponding disk file). In a typical application, the B-trees access to the disk file will be managed using a buffer pool and a block-replacement scheme such as LRU. Figure 12.6.1 shows a B-tree of order four. Each node contains up to three keys, and internal nodes have up to four children. Figure 12.6.1: A B-tree of order four. Search in a B-tree is a generalization of search in a 2-3 tree. It is an alternating two- step process, beginning with the root node of the B-tree. 1. Perform a binary search on the records in the current node. If a record with the search key is found, then return that record. If the', 'file': '12.6. B-Trees  CS3 Data Structures & Algorithms.pdf', 'page': '1'}
ICS 46 Spring 2022 | News | Course Reference | Schedule | Project Guide | Notes and Examples | Reinforcement Exercises | Grade Calculator | About Alex ICS 46 Spring 2022 Notes and Examples: AVL Trees Why we must care about binary search tree balancing We've seen previously that the performance characteristics of binary search trees can vary rather wildly, and that they're mainly dependent on the shape of the tree, with the height of the tree being the key determining factor. By definition, binary search trees restrict what keys are allowed to present in which nodes smaller keys have to be in left subtrees and larger keys in right subtrees but they specify no restriction on the tree's shape, meaning that both of these are perfectly legal binary search trees containing the keys 1, 2, 3, 4, 5, 6, and 7. Yet, while both of these are legal, one is better than the other, because the height of the first tree (called a perfect binary tree) is smaller than the height of the second (called a degenerate tree). These two shapes represent the two extremes the best and worst possible shapes for a binary search tree containing seven keys. - {'chunk': ""ICS 46 Spring 2022 | News | Course Reference | Schedule | Project Guide | Notes and Examples | Reinforcement Exercises | Grade Calculator | About Alex ICS 46 Spring 2022 Notes and Examples: AVL Trees Why we must care about binary search tree balancing We've seen previously that the performance characteristics of binary search trees can vary rather wildly, and that they're mainly dependent on the shape of the tree, with the height of the tree being the key determining factor. By definition, binary search trees restrict what keys are allowed to present in which nodes smaller keys have to be in left subtrees and larger keys in right subtrees but they specify no restriction on the tree's shape, meaning that both of these are perfectly legal binary search trees containing the keys 1, 2, 3, 4, 5, 6, and 7. Yet, while both of these are legal, one is better than the other, because the height of the first tree (called a perfect binary tree) is smaller than the height of the second (called a degenerate tree). These two shapes represent the two extremes the best and worst possible shapes for a binary search tree containing seven keys."", 'file': 'ICS 46 Spring 2022, Notes and Examples_ AVL Trees.pdf', 'page': '0'}"
chroma,nomic-embed-text,1000,100,15.48604702949524,7.77631,284,"Something with Fast Insert and Fast Search? - Binary Search Tree - a binary tree where every node in the left subtree is less than its parent and every node in the right subtree is greater than its parent. 13 Image from: https://courses.grainger.illinois.edu/cs225/sp2019/notes/bst/ - {'chunk': 'Something with Fast Insert and Fast Search? - Binary Search Tree - a binary tree where every node in the left subtree is less than its parent and every node in the right subtree is greater than its parent. 13 Image from: https://courses.grainger.illinois.edu/cs225/sp2019/notes/bst/', 'file': '02 - Foundations.pdf', 'page': '12'}
Chapter 12: Binary Search Trees A binary search tree is a binary tree with a special property called the BST-property, which is given as follows: For all nodes x and y, if y belongs to the left subtree of x, then the key at y is less than the key at x, and if y belongs to the right subtree of x, then the key at y is greater than the key at x. We will assume that the keys of a BST are pairwise distinct. Each node has the following attributes: p, left, and right, which are pointers to the parent, the left child, and the right child, respectively, and key, which is key stored at the node. 1 - {'chunk': 'Chapter 12: Binary Search Trees A binary search tree is a binary tree with a special property called the BST-property, which is given as follows: For all nodes x and y, if y belongs to the left subtree of x, then the key at y is less than the key at x, and if y belongs to the right subtree of x, then the key at y is greater than the key at x. We will assume that the keys of a BST are pairwise distinct. Each node has the following attributes: p, left, and right, which are pointers to the parent, the left child, and the right child, respectively, and key, which is key stored at the node. 1', 'file': 'C12-bst.pdf', 'page': '0'}
time we insert a key into our binary search tree, it would ideally still be a perfect binary tree, in which case we'd know that the height of the tree would always be (log n), with a commensurate effect on performance. - {'chunk': ""time we insert a key into our binary search tree, it would ideally still be a perfect binary tree, in which case we'd know that the height of the tree would always be (log n), with a commensurate effect on performance."", 'file': 'ICS 46 Spring 2022, Notes and Examples_ AVL Trees.pdf', 'page': '0'}
The B-tree is a generalization of the 2-3 tree. Put another way, a 2-3 tree is a B-tree of order three. Normally, the size of a node in the B-tree is chosen to fill a disk block. A B- tree node implementation typically allows 100 or more children. Thus, a B-tree node is equivalent to a disk block, and a pointer value stored in the tree is actually the number of the block containing the child node (usually interpreted as an offset from the beginning of the corresponding disk file). In a typical application, the B-trees access to the disk file will be managed using a buffer pool and a block-replacement scheme such as LRU. Figure 12.6.1 shows a B-tree of order four. Each node contains up to three keys, and internal nodes have up to four children. Figure 12.6.1: A B-tree of order four. Search in a B-tree is a generalization of search in a 2-3 tree. It is an alternating two- step process, beginning with the root node of the B-tree. 1. Perform a binary search on the records in the current node. If a record with the search key is found, then return that record. If the - {'chunk': 'The B-tree is a generalization of the 2-3 tree. Put another way, a 2-3 tree is a B-tree of order three. Normally, the size of a node in the B-tree is chosen to fill a disk block. A B- tree node implementation typically allows 100 or more children. Thus, a B-tree node is equivalent to a disk block, and a pointer value stored in the tree is actually the number of the block containing the child node (usually interpreted as an offset from the beginning of the corresponding disk file). In a typical application, the B-trees access to the disk file will be managed using a buffer pool and a block-replacement scheme such as LRU. Figure 12.6.1 shows a B-tree of order four. Each node contains up to three keys, and internal nodes have up to four children. Figure 12.6.1: A B-tree of order four. Search in a B-tree is a generalization of search in a 2-3 tree. It is an alternating two- step process, beginning with the root node of the B-tree. 1. Perform a binary search on the records in the current node. If a record with the search key is found, then return that record. If the', 'file': '12.6. B-Trees  CS3 Data Structures & Algorithms.pdf', 'page': '1'}
ICS 46 Spring 2022 | News | Course Reference | Schedule | Project Guide | Notes and Examples | Reinforcement Exercises | Grade Calculator | About Alex ICS 46 Spring 2022 Notes and Examples: AVL Trees Why we must care about binary search tree balancing We've seen previously that the performance characteristics of binary search trees can vary rather wildly, and that they're mainly dependent on the shape of the tree, with the height of the tree being the key determining factor. By definition, binary search trees restrict what keys are allowed to present in which nodes smaller keys have to be in left subtrees and larger keys in right subtrees but they specify no restriction on the tree's shape, meaning that both of these are perfectly legal binary search trees containing the keys 1, 2, 3, 4, 5, 6, and 7. Yet, while both of these are legal, one is better than the other, because the height of the first tree (called a perfect binary tree) is smaller than the height of the second (called a degenerate tree). These two shapes represent the two extremes the best and worst possible shapes for a binary search tree containing seven keys. - {'chunk': ""ICS 46 Spring 2022 | News | Course Reference | Schedule | Project Guide | Notes and Examples | Reinforcement Exercises | Grade Calculator | About Alex ICS 46 Spring 2022 Notes and Examples: AVL Trees Why we must care about binary search tree balancing We've seen previously that the performance characteristics of binary search trees can vary rather wildly, and that they're mainly dependent on the shape of the tree, with the height of the tree being the key determining factor. By definition, binary search trees restrict what keys are allowed to present in which nodes smaller keys have to be in left subtrees and larger keys in right subtrees but they specify no restriction on the tree's shape, meaning that both of these are perfectly legal binary search trees containing the keys 1, 2, 3, 4, 5, 6, and 7. Yet, while both of these are legal, one is better than the other, because the height of the first tree (called a perfect binary tree) is smaller than the height of the second (called a degenerate tree). These two shapes represent the two extremes the best and worst possible shapes for a binary search tree containing seven keys."", 'file': 'ICS 46 Spring 2022, Notes and Examples_ AVL Trees.pdf', 'page': '0'}"

Vector DB,Embedding Type,Chunk Size,Overlap,Speed (s),Memory (MB),Total Chunks,Resulting Documents
redis,nomic-embed-text,200,0,44.34214925765991,2.734424,647,"doc::02 - Foundations.pdf_page_12_chunk_Something with Fast Insert and Fast Search? - Binary Search Tree - a binary tree where every node in the left subtree is less than its parent and every node in the right subtree is greater than its parent. 13 Image from: https://courses.grainger.illinois.edu/cs225/sp2019/notes/bst/ - 0.166970312595
doc::C12-bst.pdf_page_0_chunk_Chapter 12: Binary Search Trees A binary search tree is a binary tree with a special property called the BST-property, which is given as follows: For all nodes x and y, if y belongs to the left subtree of x, then the key at y is less than the key at x, and if y belongs to the right subtree of x, then the key at y is greater than the key at x. We will assume that the keys of a BST are pairwise distinct. Each node has the following attributes: p, left, and right, which are pointers to the parent, the left child, and the right child, respectively, and key, which is key stored at the node. 1 - 0.196106314659
doc::ICS 46 Spring 2022, Notes and Examples_ AVL Trees.pdf_page_0_chunk_time we insert a key into our binary search tree, it would ideally still be a perfect binary tree, in which case we'd know that the height of the tree would always be (log n), with a commensurate effect on performance. - 0.230523705482
doc::12.6. B-Trees  CS3 Data Structures & Algorithms.pdf_page_0_chunk_as LRU. Figure 12.6.1 shows a B-tree of order four. Each node contains up to three keys, and internal nodes have up to four children. Figure 12.6.1: A B-tree of order four. Search in a B-tree is a generalization of search in a 2-3 tree. It is an alternating two-step process, beginning with the root node of the B- tree. 1. Perform a binary search on the records in the current node. If a record with the search key is found, then return that record. If the current node is a leaf node and the key is not found, then report an unsuccessful search. m m/2 m 24 15 20 33 45 48 10 12 18 21 23 30 30 38 47 50 52 60 - 0.244145333767
doc::ICS 46 Spring 2022, Notes and Examples_ AVL Trees.pdf_page_0_chunk_ICS 46 Spring 2022 | News | Course Reference | Schedule | Project Guide | Notes and Examples | Reinforcement Exercises | Grade Calculator | About Alex ICS 46 Spring 2022 Notes and Examples: AVL Trees Why we must care about binary search tree balancing We've seen previously that the performance characteristics of binary search trees can vary rather wildly, and that they're mainly dependent on the shape of the tree, with the height of the tree being the key determining factor. By definition, binary search trees restrict what keys are allowed to present in which nodes smaller keys have to be in left subtrees and larger keys in right subtrees but they specify no restriction on the tree's shape, meaning that both of these are perfectly legal binary search trees containing the keys 1, 2, 3, 4, 5, 6, and 7. Yet, while both of these are legal, one is better than the other, because the height of the first tree (called a perfect binary tree) is smaller than the height of the second (called a degenerate tree). These two shapes represent the two extremes the best and worst possible shapes for a binary search tree containing seven keys. - 0.252324342728"
redis,nomic-embed-text,200,50,53.34543418884277,2.579529,785,"doc::02 - Foundations.pdf_page_12_chunk_Something with Fast Insert and Fast Search? - Binary Search Tree - a binary tree where every node in the left subtree is less than its parent and every node in the right subtree is greater than its parent. 13 Image from: https://courses.grainger.illinois.edu/cs225/sp2019/notes/bst/ - 0.166970312595
doc::C12-bst.pdf_page_0_chunk_Chapter 12: Binary Search Trees A binary search tree is a binary tree with a special property called the BST-property, which is given as follows: For all nodes x and y, if y belongs to the left subtree of x, then the key at y is less than the key at x, and if y belongs to the right subtree of x, then the key at y is greater than the key at x. We will assume that the keys of a BST are pairwise distinct. Each node has the following attributes: p, left, and right, which are pointers to the parent, the left child, and the right child, respectively, and key, which is key stored at the node. 1 - 0.196106314659
doc::ICS 46 Spring 2022, Notes and Examples_ AVL Trees.pdf_page_0_chunk_time we insert a key into our binary search tree, it would ideally still be a perfect binary tree, in which case we'd know that the height of the tree would always be (log n), with a commensurate effect on performance. - 0.230523705482
doc::12.6. B-Trees  CS3 Data Structures & Algorithms.pdf_page_0_chunk_as LRU. Figure 12.6.1 shows a B-tree of order four. Each node contains up to three keys, and internal nodes have up to four children. Figure 12.6.1: A B-tree of order four. Search in a B-tree is a generalization of search in a 2-3 tree. It is an alternating two-step process, beginning with the root node of the B- tree. 1. Perform a binary search on the records in the current node. If a record with the search key is found, then return that record. If the current node is a leaf node and the key is not found, then report an unsuccessful search. m m/2 m 24 15 20 33 45 48 10 12 18 21 23 30 30 38 47 50 52 60 - 0.244145333767
doc::ICS 46 Spring 2022, Notes and Examples_ AVL Trees.pdf_page_0_chunk_ICS 46 Spring 2022 | News | Course Reference | Schedule | Project Guide | Notes and Examples | Reinforcement Exercises | Grade Calculator | About Alex ICS 46 Spring 2022 Notes and Examples: AVL Trees Why we must care about binary search tree balancing We've seen previously that the performance characteristics of binary search trees can vary rather wildly, and that they're mainly dependent on the shape of the tree, with the height of the tree being the key determining factor. By definition, binary search trees restrict what keys are allowed to present in which nodes smaller keys have to be in left subtrees and larger keys in right subtrees but they specify no restriction on the tree's shape, meaning that both of these are perfectly legal binary search trees containing the keys 1, 2, 3, 4, 5, 6, and 7. Yet, while both of these are legal, one is better than the other, because the height of the first tree (called a perfect binary tree) is smaller than the height of the second (called a degenerate tree). These two shapes represent the two extremes the best and worst possible shapes for a binary search tree containing seven keys. - 0.252324342728"
redis,nomic-embed-text,200,100,65.72824192047119,2.698923,977,"doc::02 - Foundations.pdf_page_12_chunk_Something with Fast Insert and Fast Search? - Binary Search Tree - a binary tree where every node in the left subtree is less than its parent and every node in the right subtree is greater than its parent. 13 Image from: https://courses.grainger.illinois.edu/cs225/sp2019/notes/bst/ - 0.166970312595
doc::C12-bst.pdf_page_0_chunk_Chapter 12: Binary Search Trees A binary search tree is a binary tree with a special property called the BST-property, which is given as follows: For all nodes x and y, if y belongs to the left subtree of x, then the key at y is less than the key at x, and if y belongs to the right subtree of x, then the key at y is greater than the key at x. We will assume that the keys of a BST are pairwise distinct. Each node has the following attributes: p, left, and right, which are pointers to the parent, the left child, and the right child, respectively, and key, which is key stored at the node. 1 - 0.196106314659
doc::BST Code.pdf_page_1_chunk_in the binary search tree. tree_height() -> int: Calculates the height of the binary search tree. get_keys_in_order() -> List[Any]: Returns a list of keys in the binary search tree in ascending order. get_leaf_keys() -> List[Any]: Returns a list of keys of leaf nodes in the binary search tree. get_avg_value_list_len() -> float: Calculates the average length of value lists in the binary search tree. """""" def __init__(self): super().__init__() self.root: Optional[BSTNode] = None def _insert_recursive(self, current_node: Optional[BSTNode], key: Any, value: Any) -> BSTNode: """""" - 0.223883807659
doc::ICS 46 Spring 2022, Notes and Examples_ AVL Trees.pdf_page_0_chunk_time we insert a key into our binary search tree, it would ideally still be a perfect binary tree, in which case we'd know that the height of the tree would always be (log n), with a commensurate effect on performance. - 0.230523705482
doc::BST Code.pdf_page_3_chunk_of nodes in the binary search tree. Parameters: - node (Optional[BSTNode]): The root node of the binary search tree. Returns: - int: The number of nodes in the binary search tree. """""" if node is None: return 0 return 1 + self._count_nodes(node.left) + self._count_nodes(node.right) def _tree_height(self, node: Optional[BSTNode]) -> int: """""" - 0.238147854805"
redis,nomic-embed-text,500,0,43.10445499420166,2.527298,507,"doc::02 - Foundations.pdf_page_12_chunk_Something with Fast Insert and Fast Search? - Binary Search Tree - a binary tree where every node in the left subtree is less than its parent and every node in the right subtree is greater than its parent. 13 Image from: https://courses.grainger.illinois.edu/cs225/sp2019/notes/bst/ - 0.166970312595
doc::C12-bst.pdf_page_0_chunk_Chapter 12: Binary Search Trees A binary search tree is a binary tree with a special property called the BST-property, which is given as follows: For all nodes x and y, if y belongs to the left subtree of x, then the key at y is less than the key at x, and if y belongs to the right subtree of x, then the key at y is greater than the key at x. We will assume that the keys of a BST are pairwise distinct. Each node has the following attributes: p, left, and right, which are pointers to the parent, the left child, and the right child, respectively, and key, which is key stored at the node. 1 - 0.196106314659
doc::BST Code.pdf_page_1_chunk_in the binary search tree. tree_height() -> int: Calculates the height of the binary search tree. get_keys_in_order() -> List[Any]: Returns a list of keys in the binary search tree in ascending order. get_leaf_keys() -> List[Any]: Returns a list of keys of leaf nodes in the binary search tree. get_avg_value_list_len() -> float: Calculates the average length of value lists in the binary search tree. """""" def __init__(self): super().__init__() self.root: Optional[BSTNode] = None def _insert_recursive(self, current_node: Optional[BSTNode], key: Any, value: Any) -> BSTNode: """""" - 0.223883807659
doc::ICS 46 Spring 2022, Notes and Examples_ AVL Trees.pdf_page_0_chunk_time we insert a key into our binary search tree, it would ideally still be a perfect binary tree, in which case we'd know that the height of the tree would always be (log n), with a commensurate effect on performance. - 0.230523705482
doc::BST Code.pdf_page_3_chunk_of nodes in the binary search tree. Parameters: - node (Optional[BSTNode]): The root node of the binary search tree. Returns: - int: The number of nodes in the binary search tree. """""" if node is None: return 0 return 1 + self._count_nodes(node.left) + self._count_nodes(node.right) def _tree_height(self, node: Optional[BSTNode]) -> int: """""" - 0.238147854805"
redis,nomic-embed-text,500,50,43.07365608215332,2.486029,508,"doc::02 - Foundations.pdf_page_12_chunk_Something with Fast Insert and Fast Search? - Binary Search Tree - a binary tree where every node in the left subtree is less than its parent and every node in the right subtree is greater than its parent. 13 Image from: https://courses.grainger.illinois.edu/cs225/sp2019/notes/bst/ - 0.166970312595
doc::C12-bst.pdf_page_0_chunk_Chapter 12: Binary Search Trees A binary search tree is a binary tree with a special property called the BST-property, which is given as follows: For all nodes x and y, if y belongs to the left subtree of x, then the key at y is less than the key at x, and if y belongs to the right subtree of x, then the key at y is greater than the key at x. We will assume that the keys of a BST are pairwise distinct. Each node has the following attributes: p, left, and right, which are pointers to the parent, the left child, and the right child, respectively, and key, which is key stored at the node. 1 - 0.196106314659
doc::BST Code.pdf_page_1_chunk_in the binary search tree. tree_height() -> int: Calculates the height of the binary search tree. get_keys_in_order() -> List[Any]: Returns a list of keys in the binary search tree in ascending order. get_leaf_keys() -> List[Any]: Returns a list of keys of leaf nodes in the binary search tree. get_avg_value_list_len() -> float: Calculates the average length of value lists in the binary search tree. """""" def __init__(self): super().__init__() self.root: Optional[BSTNode] = None def _insert_recursive(self, current_node: Optional[BSTNode], key: Any, value: Any) -> BSTNode: """""" - 0.223883807659
doc::ICS 46 Spring 2022, Notes and Examples_ AVL Trees.pdf_page_0_chunk_time we insert a key into our binary search tree, it would ideally still be a perfect binary tree, in which case we'd know that the height of the tree would always be (log n), with a commensurate effect on performance. - 0.230523705482
doc::BST Code.pdf_page_3_chunk_of nodes in the binary search tree. Parameters: - node (Optional[BSTNode]): The root node of the binary search tree. Returns: - int: The number of nodes in the binary search tree. """""" if node is None: return 0 return 1 + self._count_nodes(node.left) + self._count_nodes(node.right) def _tree_height(self, node: Optional[BSTNode]) -> int: """""" - 0.238147854805"
redis,nomic-embed-text,500,100,43.373006105422974,2.482901,512,"doc::02 - Foundations.pdf_page_12_chunk_Something with Fast Insert and Fast Search? - Binary Search Tree - a binary tree where every node in the left subtree is less than its parent and every node in the right subtree is greater than its parent. 13 Image from: https://courses.grainger.illinois.edu/cs225/sp2019/notes/bst/ - 0.166970312595
doc::C12-bst.pdf_page_0_chunk_Chapter 12: Binary Search Trees A binary search tree is a binary tree with a special property called the BST-property, which is given as follows: For all nodes x and y, if y belongs to the left subtree of x, then the key at y is less than the key at x, and if y belongs to the right subtree of x, then the key at y is greater than the key at x. We will assume that the keys of a BST are pairwise distinct. Each node has the following attributes: p, left, and right, which are pointers to the parent, the left child, and the right child, respectively, and key, which is key stored at the node. 1 - 0.196106314659
doc::BST Code.pdf_page_1_chunk_in the binary search tree. tree_height() -> int: Calculates the height of the binary search tree. get_keys_in_order() -> List[Any]: Returns a list of keys in the binary search tree in ascending order. get_leaf_keys() -> List[Any]: Returns a list of keys of leaf nodes in the binary search tree. get_avg_value_list_len() -> float: Calculates the average length of value lists in the binary search tree. """""" def __init__(self): super().__init__() self.root: Optional[BSTNode] = None def _insert_recursive(self, current_node: Optional[BSTNode], key: Any, value: Any) -> BSTNode: """""" - 0.223883807659
doc::ICS 46 Spring 2022, Notes and Examples_ AVL Trees.pdf_page_0_chunk_time we insert a key into our binary search tree, it would ideally still be a perfect binary tree, in which case we'd know that the height of the tree would always be (log n), with a commensurate effect on performance. - 0.230523705482
doc::BST Code.pdf_page_3_chunk_of nodes in the binary search tree. Parameters: - node (Optional[BSTNode]): The root node of the binary search tree. Returns: - int: The number of nodes in the binary search tree. """""" if node is None: return 0 return 1 + self._count_nodes(node.left) + self._count_nodes(node.right) def _tree_height(self, node: Optional[BSTNode]) -> int: """""" - 0.238147854805"
redis,nomic-embed-text,1000,0,41.255592823028564,2.482718,498,"doc::02 - Foundations.pdf_page_12_chunk_Something with Fast Insert and Fast Search? - Binary Search Tree - a binary tree where every node in the left subtree is less than its parent and every node in the right subtree is greater than its parent. 13 Image from: https://courses.grainger.illinois.edu/cs225/sp2019/notes/bst/ - 0.166970312595
doc::C12-bst.pdf_page_0_chunk_Chapter 12: Binary Search Trees A binary search tree is a binary tree with a special property called the BST-property, which is given as follows: For all nodes x and y, if y belongs to the left subtree of x, then the key at y is less than the key at x, and if y belongs to the right subtree of x, then the key at y is greater than the key at x. We will assume that the keys of a BST are pairwise distinct. Each node has the following attributes: p, left, and right, which are pointers to the parent, the left child, and the right child, respectively, and key, which is key stored at the node. 1 - 0.196106314659
doc::BST Code.pdf_page_1_chunk_in the binary search tree. tree_height() -> int: Calculates the height of the binary search tree. get_keys_in_order() -> List[Any]: Returns a list of keys in the binary search tree in ascending order. get_leaf_keys() -> List[Any]: Returns a list of keys of leaf nodes in the binary search tree. get_avg_value_list_len() -> float: Calculates the average length of value lists in the binary search tree. """""" def __init__(self): super().__init__() self.root: Optional[BSTNode] = None def _insert_recursive(self, current_node: Optional[BSTNode], key: Any, value: Any) -> BSTNode: """""" - 0.223883807659
doc::ICS 46 Spring 2022, Notes and Examples_ AVL Trees.pdf_page_0_chunk_time we insert a key into our binary search tree, it would ideally still be a perfect binary tree, in which case we'd know that the height of the tree would always be (log n), with a commensurate effect on performance. - 0.230523705482
doc::BST Code.pdf_page_3_chunk_of nodes in the binary search tree. Parameters: - node (Optional[BSTNode]): The root node of the binary search tree. Returns: - int: The number of nodes in the binary search tree. """""" if node is None: return 0 return 1 + self._count_nodes(node.left) + self._count_nodes(node.right) def _tree_height(self, node: Optional[BSTNode]) -> int: """""" - 0.238147854805"
redis,nomic-embed-text,1000,50,41.50206804275513,2.542649,498,"doc::02 - Foundations.pdf_page_12_chunk_Something with Fast Insert and Fast Search? - Binary Search Tree - a binary tree where every node in the left subtree is less than its parent and every node in the right subtree is greater than its parent. 13 Image from: https://courses.grainger.illinois.edu/cs225/sp2019/notes/bst/ - 0.166970312595
doc::C12-bst.pdf_page_0_chunk_Chapter 12: Binary Search Trees A binary search tree is a binary tree with a special property called the BST-property, which is given as follows: For all nodes x and y, if y belongs to the left subtree of x, then the key at y is less than the key at x, and if y belongs to the right subtree of x, then the key at y is greater than the key at x. We will assume that the keys of a BST are pairwise distinct. Each node has the following attributes: p, left, and right, which are pointers to the parent, the left child, and the right child, respectively, and key, which is key stored at the node. 1 - 0.196106314659
doc::BST Code.pdf_page_1_chunk_in the binary search tree. tree_height() -> int: Calculates the height of the binary search tree. get_keys_in_order() -> List[Any]: Returns a list of keys in the binary search tree in ascending order. get_leaf_keys() -> List[Any]: Returns a list of keys of leaf nodes in the binary search tree. get_avg_value_list_len() -> float: Calculates the average length of value lists in the binary search tree. """""" def __init__(self): super().__init__() self.root: Optional[BSTNode] = None def _insert_recursive(self, current_node: Optional[BSTNode], key: Any, value: Any) -> BSTNode: """""" - 0.223883807659
doc::ICS 46 Spring 2022, Notes and Examples_ AVL Trees.pdf_page_0_chunk_time we insert a key into our binary search tree, it would ideally still be a perfect binary tree, in which case we'd know that the height of the tree would always be (log n), with a commensurate effect on performance. - 0.230523705482
doc::BST Code.pdf_page_3_chunk_of nodes in the binary search tree. Parameters: - node (Optional[BSTNode]): The root node of the binary search tree. Returns: - int: The number of nodes in the binary search tree. """""" if node is None: return 0 return 1 + self._count_nodes(node.left) + self._count_nodes(node.right) def _tree_height(self, node: Optional[BSTNode]) -> int: """""" - 0.238147854805"
redis,nomic-embed-text,1000,100,42.394370794296265,2.528153,498,"doc::02 - Foundations.pdf_page_12_chunk_Something with Fast Insert and Fast Search? - Binary Search Tree - a binary tree where every node in the left subtree is less than its parent and every node in the right subtree is greater than its parent. 13 Image from: https://courses.grainger.illinois.edu/cs225/sp2019/notes/bst/ - 0.166970312595
doc::C12-bst.pdf_page_0_chunk_Chapter 12: Binary Search Trees A binary search tree is a binary tree with a special property called the BST-property, which is given as follows: For all nodes x and y, if y belongs to the left subtree of x, then the key at y is less than the key at x, and if y belongs to the right subtree of x, then the key at y is greater than the key at x. We will assume that the keys of a BST are pairwise distinct. Each node has the following attributes: p, left, and right, which are pointers to the parent, the left child, and the right child, respectively, and key, which is key stored at the node. 1 - 0.196106314659
doc::BST Code.pdf_page_1_chunk_in the binary search tree. tree_height() -> int: Calculates the height of the binary search tree. get_keys_in_order() -> List[Any]: Returns a list of keys in the binary search tree in ascending order. get_leaf_keys() -> List[Any]: Returns a list of keys of leaf nodes in the binary search tree. get_avg_value_list_len() -> float: Calculates the average length of value lists in the binary search tree. """""" def __init__(self): super().__init__() self.root: Optional[BSTNode] = None def _insert_recursive(self, current_node: Optional[BSTNode], key: Any, value: Any) -> BSTNode: """""" - 0.223883807659
doc::ICS 46 Spring 2022, Notes and Examples_ AVL Trees.pdf_page_0_chunk_time we insert a key into our binary search tree, it would ideally still be a perfect binary tree, in which case we'd know that the height of the tree would always be (log n), with a commensurate effect on performance. - 0.230523705482
doc::BST Code.pdf_page_3_chunk_of nodes in the binary search tree. Parameters: - node (Optional[BSTNode]): The root node of the binary search tree. Returns: - int: The number of nodes in the binary search tree. """""" if node is None: return 0 return 1 + self._count_nodes(node.left) + self._count_nodes(node.right) def _tree_height(self, node: Optional[BSTNode]) -> int: """""" - 0.238147854805"
